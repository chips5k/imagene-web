Data structure 
==============
{
    generations: [{
        individuals: [...],
        samples: [...]
    }],
    individuals: [{
        id: 0,
        expression: [...],
        fitness: 0
        previousId: 0,
        parentA: 0,
        parentB: 0
    }],
    samples: [{
        id: 0,
        redExpressionId: 0,
        greenExpressionId: 0,
        blueExpressionId: 0,
        fitness: 0,
        redThreshold: [0, 255],
        greenThreshold: [0, 255],
        blueThreshold: [0, 255],
        width: 320,
        height: 320,
        type: 'polar|cartesian'
        symmetric: true,
        cache: []
    }],
    initialGenerationConfig: {
        initialPopulationSize: 24,
        initialMinExpressionDepth: 0,
        initialMaxExpressionDepth: 0,
    },
    operands: [{
        key: 'pX',
        value: (x, y) => x,
        fitness: 0
    }],
    doubleOperators: [{
        key: '+',
        value: (a, b) => a + b,
        fitness: 0
    }],
    singleOperators: [{
        key: 'sin',
        value: (n) => Math.sin(n)
    }]
    
}

actions
================

updateOperandFitness
updateDoubleOperatorFitness
updateSingleOperatorFitness
 - all of the above update the fitness values of operands, and operators

createInitialGeneration
 - creates a new generation object with id 1
 - removes all generations, individuals and samples from the store
 - adds the new generation to the store

createInitialGenerationPopulation
 - creates a set of individuals from specified config
 - assigns individual ids to the initial generation
 - updates the store with the new individuals
 - updates the store with the updated generation
 - updates initialGenerationConfig in the store

createSamples
 - creates a set of samples for selected generation, based on config panel
 - assigns the sample ids to the selected generation
 - updates the store with the updated generation
 - adds the samples to the store

 updateSampleFitness
 - updates fitness value of a sample
 - distributes fitness value to underlying r,g,b individuals
 - updates individuals in store
 - updates sample in store

evolveNewGeneration
 - creates a new generation object
 - generates new individuals from previous generation
 - updates store with new individuals
 - assigns individuals to new generation
 - updates store with new generation

updateSample
 - updates store with current data for sample

