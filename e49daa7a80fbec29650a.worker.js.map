{"version":3,"sources":["../e49daa7a80fbec29650a.worker.js","../webpack/bootstrap e49daa7a80fbec29650a","lib/GenerationSampleWorker.worker.js","../node_modules/webpack/buildin/global.js","lib/expressions.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","value","global","__WEBPACK_IMPORTED_MODULE_0__expressions__","globals","this","onmessage","e","dataArray","Uint8ClampedArray","data","sample","width","height","rgbRange","min","r","g","b","all","max","array","length","x","y","Math","floor","evaluateX","evaluateY","coordinateType","a","sqrt","pow","atan","PI","redIndividual","expression","slice","greenIndividual","blueIndividual","diffs","thresholdRanges","redThreshold","greenThreshold","blueThreshold","postMessage","bind","Function","eval","window","tokenEvaluators","solveExpression","Symbol","iterator","doubleOperators","+","-","/","*","^","abs","parseInt","%","CIR","sin","singleOperators","double","triple","cos","tan","log","operands","pX","pY","operandStack","operatorStack","shift","isNaN","parseFloat","push","isFinite","f","pop","Error"],"mappings":"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","file":"e49daa7a80fbec29650a.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/imagene-web/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__expressions__ = __webpack_require__(2);\n//Small hack to support unit tests na dissues with mocking a web worker\nif(!global){globals=this;}global.onmessage=function(e){var dataArray=new Uint8ClampedArray(e.data.sample.width*e.data.sample.height*4);var rgbRange={min:{r:false,g:false,b:false,all:false},max:{r:false,g:false,b:false,all:false}};var array=[];for(var i=0;i<dataArray.length;i+=4){var x=i/4%e.data.sample.width;var y=Math.floor(i/4/e.data.sample.height);var evaluateX=x+1;var evaluateY=y+1;if(e.data.coordinateType==='polar'){var _r=void 0,a=void 0;evaluateX-=e.data.sample.width/2;evaluateY-=e.data.sample.height/2;_r=Math.sqrt(Math.pow(evaluateX,2)+Math.pow(evaluateY,2));/* -90 to +270 */// if (x == 0 && y == 0) {\n//     a = 0;\n// } else if (x >= 0) {\n//     a = Math.asin(evaluateY / r);\n// } else if (x < 0) {\n//     a = 0 - Math.asin(evaluateY / r) + Math.PI;\n// }\n/* 0 to 360 */// if (evaluateX > 0 && evaluateY >= 0){\n//     a = Math.atan(evaluateY / evaluateX);\n// }\n// else if (evaluateX > 0 && evaluateY < 0) {\n//     a = Math.atan(evaluateY / evaluateX) + Math.PI + Math.PI;\n// }\n// else if (evaluateX < 0) {\n//     a = Math.atan(evaluateY / evaluateX) + Math.PI;\n// }\n// else if (evaluateX == 0 && evaluateY > 0) {\n//     a = Math.PI / 2;\n// }\n// else if (evaluateX == 0 && evaluateY < 0) {\n//     a = 3 / 2 * Math.PI;\n// }\n// else if (evaluateX == 0 && evaluateY == 0) {\n//     a = 0;\n// }\n/* -180 to +180 */if(evaluateX>0){a=Math.atan(evaluateY/evaluateX);}else if(evaluateX<0&&evaluateY>=0){a=Math.atan(evaluateY/evaluateX)+Math.PI;}else if(evaluateX<0&&evaluateY<0){a=Math.atan(evaluateY/evaluateX)-Math.PI;}else if(evaluateX==0&&evaluateY>0){a=Math.PI/2;}else if(evaluateX==0&&evaluateY<0){a=0-Math.PI/2;}else if(evaluateX==0&&evaluateY==0){a=0;}evaluateX=_r;evaluateY=a;}var r=Object(__WEBPACK_IMPORTED_MODULE_0__expressions__[\"a\" /* solveExpression */])(__WEBPACK_IMPORTED_MODULE_0__expressions__[\"b\" /* tokenEvaluators */],e.data.sample.redIndividual.expression.slice(0),evaluateX,evaluateY);var g=Object(__WEBPACK_IMPORTED_MODULE_0__expressions__[\"a\" /* solveExpression */])(__WEBPACK_IMPORTED_MODULE_0__expressions__[\"b\" /* tokenEvaluators */],e.data.sample.greenIndividual.expression.slice(0),evaluateX,evaluateY);var b=Object(__WEBPACK_IMPORTED_MODULE_0__expressions__[\"a\" /* solveExpression */])(__WEBPACK_IMPORTED_MODULE_0__expressions__[\"b\" /* tokenEvaluators */],e.data.sample.blueIndividual.expression.slice(0),evaluateX,evaluateY);array[i]=r;array[i+1]=g;array[i+2]=b;array[i+3]=255;if(rgbRange.min.r===false||r<rgbRange.min.r){rgbRange.min.r=r;}if(rgbRange.min.g===false||g<rgbRange.min.g){rgbRange.min.g=g;}if(rgbRange.min.b===false||b<rgbRange.min.b){rgbRange.min.b=b;}if(rgbRange.max.r===false||r>rgbRange.max.r){rgbRange.max.r=r;}if(rgbRange.max.g===false||g>rgbRange.max.g){rgbRange.max.g=g;}if(rgbRange.max.b===false||b>rgbRange.max.b){rgbRange.max.b=b;}}var diffs={r:rgbRange.max.r-rgbRange.min.r,g:rgbRange.max.g-rgbRange.min.g,b:rgbRange.max.b-rgbRange.min.b};var thresholdRanges={r:e.data.sample.redThreshold[1]-e.data.sample.redThreshold[0],g:e.data.sample.greenThreshold[1]-e.data.sample.greenThreshold[0],b:e.data.sample.blueThreshold[1]-e.data.sample.blueThreshold[0]};for(var _i=0;_i<dataArray.length;_i+=4){var _r2=array[_i];var _g=array[_i+1];var _b=array[_i+2];var _a=array[_i+3];dataArray[_i]=(_r2-rgbRange.min.r)*thresholdRanges.r/diffs.r+e.data.sample.redThreshold[0];dataArray[_i+1]=(_g-rgbRange.min.g)*thresholdRanges.g/diffs.g+e.data.sample.greenThreshold[0];dataArray[_i+2]=(_b-rgbRange.min.b)*thresholdRanges.b/diffs.b+e.data.sample.blueThreshold[0];dataArray[_i+3]=_a;}postMessage(dataArray);}.bind(this);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export OPERATOR_DOUBLE */\n/* unused harmony export OPERATOR_SINGLE */\n/* unused harmony export OPERAND */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return tokenEvaluators; });\n/* unused harmony export tokenCreators */\n/* unused harmony export getToken */\n/* unused harmony export buildExpression */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return solveExpression; });\n/* unused harmony export mutateExpression */\n/* unused harmony export findBinaryTreeNodeByIndex */\n/* unused harmony export insertNodeIntoBinaryTreeAtIndex */\n/* unused harmony export convertExpressionToWeightedArray */\n/* unused harmony export assignWeightToExpressionNode */\n/* unused harmony export crossOverExpressions */\n/* unused harmony export expressionToTree */\n/* unused harmony export treeToString */\n/* unused harmony export treeToExpression */\nvar _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}var OPERATOR_DOUBLE='doubleOperators';var OPERATOR_SINGLE='singleOperators';var OPERAND='operands';var tokenEvaluators={doubleOperators:{'+':function _(a,b){return a+b;},'-':function _(a,b){return a-b;},'/':function _(a,b){return a/(b===0?0.000000000000001:b);},'*':function _(a,b){return a*b;},'^':function _(a,b){if(a<0&&Math.abs(a)-parseInt(Math.abs(a),10)>=0){return Math.pow(Math.abs(a===0?a+0.000000000000001:a),b);}else{return Math.pow(a,b);}},'%':function _(a,b){return a%(b===0?0.000000000000001:b);},'CIR':function CIR(a,b){return Math.sin(Math.sqrt(a*a+b*b)*Math.PI/180.00);}},singleOperators:{'sqrt':function sqrt(a){return Math.sqrt(Math.abs(a));},'double':function double(a){return Math.pow(a,2);},'triple':function triple(a){return Math.pow(a,3);},'sin':function sin(a){return Math.sin(a%3.16);},'cos':function cos(a){return Math.cos(a%3.16);},'tan':function tan(a){return Math.tan(a);},'log':function log(a){return Math.log(Math.abs(a)===0?0.000000000000001:Math.abs(a));}},operands:{'pX':function pX(x,y){return x;},'pY':function pY(x,y){return y;},'PI':function PI(){return Math.PI;}}};var tokenCreators={doubleOperators:{'+':function _(){return['+'];},'-':function _(){return['-'];},'/':function _(){return['/'];},'*':function _(){return['*'];},'%':function _(){return['%'];},'^':function _(){return['^'];},'CIR':function CIR(){return['CIR'];}},singleOperators:{'sqrt':function sqrt(){return['sqrt'];},'sin':function sin(){return['sin'];},'cos':function cos(){return['cos'];},'tan':function tan(){return['tan'];},'log':function log(){return['log'];},'double':function double(){return['double'];},'triple':function triple(){return['triple'];}},operands:{'pX':function pX(){return['pX'];},'pY':function pY(){return['pY'];},'PI':function PI(){return['PI'];},'PIx':function PIx(){return['PI','pX','*'];},'PIy':function PIy(){return['PI','pY','*'];},'cosX':function cosX(){return['pX','cos'];},'cosY':function cosY(){return['pY','cos'];},'sinX':function sinX(){return['pX','sin'];},'sinY':function sinY(){return['pY','sin'];},'tanX':function tanX(){return['pX','tan'];},'tanY':function tanY(){return['pY','tan'];},'rand':function rand(r){return[r(-10000,10000)];},'randX':function randX(r){return['pX',r(-10000,10000),'*'];},'randY':function randY(r){return['pY',r(-10000,10000),'*'];},'CIR':function CIR(){return['pX','pY','CIR'];}}};var getToken=function getToken(tokenCreators,getRandomReal,getRandomInteger,type){var keys=Object.keys(tokenCreators[type]);var item=keys[getRandomInteger(0,keys.length-1)];return tokenCreators[type][item](getRandomReal);};var buildExpression=function buildExpression(tokenSelector,getRandomInteger,minSubexpressions,maxSubexpressions){var currentDepth=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var expression=[];var type=getRandomInteger(1,2);//Build a double expression\nif(type===1){//Build a nested double expression\nif(currentDepth<maxSubexpressions){var currentMaxSubExpressions=getRandomInteger(minSubexpressions,maxSubexpressions);expression=expression.concat(buildExpression(tokenSelector,getRandomInteger,minSubexpressions,currentMaxSubExpressions,currentDepth+1));expression=expression.concat(buildExpression(tokenSelector,getRandomInteger,minSubexpressions,currentMaxSubExpressions,currentDepth+1));}else{//Build a flat double expression\nexpression=expression.concat(tokenSelector(OPERAND));expression=expression.concat(tokenSelector(OPERAND));}expression=expression.concat(tokenSelector(OPERATOR_DOUBLE));}//Build a single expression \nelse{//Build a nested singular expression\nif(currentDepth<maxSubexpressions){var _currentMaxSubExpressions=getRandomInteger(minSubexpressions,maxSubexpressions);expression=expression.concat(buildExpression(tokenSelector,getRandomInteger,minSubexpressions,_currentMaxSubExpressions,currentDepth+1));}else{//Build a flat singular expression\nexpression=expression.concat(tokenSelector(OPERAND));}expression=expression.concat(tokenSelector(OPERATOR_SINGLE));}return expression;};var solveExpression=function solveExpression(tokenEvaluators,expression,x,y){var operandStack=[];var operatorStack=[];while(expression.length){var n=expression.shift();if(!isNaN(parseFloat(n))){operandStack.push(parseFloat(n));}else{//If double operator\nif(tokenEvaluators.doubleOperators.hasOwnProperty(n)){operatorStack.push(tokenEvaluators.doubleOperators[n]);}//if single operator \nelse if(tokenEvaluators.singleOperators.hasOwnProperty(n)){operatorStack.push(tokenEvaluators.singleOperators[n]);}//if operand \nelse if(tokenEvaluators.operands.hasOwnProperty(n)){var a=tokenEvaluators.operands[n](x,y);if(isNaN(a)){}else if(!isFinite(a)){}operandStack.push(a);}}//If we have enough operands and operators to attempt a solution\nif(operandStack.length>0&&operatorStack.length>0){//Pop the function\nvar f=operatorStack.pop();//initialise result and argument vars\nvar r=void 0,_a=void 0,b=void 0;//If function only expects a single argument\nif(f.length===1){//Pop the first operand\n_a=operandStack.pop();//Evaluate the function\nr=f(_a);if(isNaN(r)){//console.log('Single Operator failure - NaN', f, a);\nr=_a;}else if(!isFinite(r)){//console.log('Single Operator failure - infinite', f, a);\n//r = r === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : -Number.MAX_VALUE;\nr=_a;}//Push the result back as an operand\noperandStack.push(r);}//Otherwise we are dealing with a double operator, so check if we have enough operands\nelse if(operandStack.length>1){//Pop both arguments\nb=operandStack.pop();_a=operandStack.pop();//And evaluate the function\nr=f(_a,b);if(isNaN(r)){//console.log('Double Operator failure - NaN', f, a, b);\nr=Math.max(_a,b);}else if(!isFinite(r)){//console.log('Double Operator failure - infinite', f, a, b);\n//r = r === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : -Number.MAX_VALUE;\nr=Math.max(_a,b);}//Push the result back onto the operand stack\noperandStack.push(r);}else{//No solution return operator\noperatorStack.push(f);}}}//If we get to this point, and only a single operand exists, the solution has been found\nif(operandStack.length===1&&operatorStack.length===0){//so return it\nreturn operandStack.pop();}//Otherwise we failed to solve\nthrow new Error('Unable to solve expression: operands: '+operandStack+' operators: '+operatorStack);};var mutateExpression=function mutateExpression(tokenEvaluators,getRandomInteger,getIndexToMutate,tokenSelector,expressionBuilder,expression){var mutatedExpression=[].concat(_toConsumableArray(expression));var index=getIndexToMutate(expression);var token=mutatedExpression[index];if(tokenEvaluators.singleOperators.hasOwnProperty(token)){//Swap token for another operand\nmutatedExpression.splice.apply(mutatedExpression,[index,1].concat(_toConsumableArray(tokenSelector(OPERATOR_SINGLE))));}if(tokenEvaluators.doubleOperators.hasOwnProperty(token)){//Swap token for another operand\nmutatedExpression.splice.apply(mutatedExpression,[index,1].concat(_toConsumableArray(tokenSelector(OPERATOR_DOUBLE))));}if(tokenEvaluators.operands.hasOwnProperty(token)){var chance=getRandomInteger(0,1);switch(chance){case 0://Swap token for another operand\nmutatedExpression.splice.apply(mutatedExpression,[index,1].concat(_toConsumableArray(tokenSelector(OPERAND))));break;case 1:default://Swap token for a subexpression\nmutatedExpression.splice.apply(mutatedExpression,[index,1].concat(_toConsumableArray(expressionBuilder(0,6,0))));break;}}return mutatedExpression;};var findBinaryTreeNodeByIndex=function findBinaryTreeNodeByIndex(node,currentIndex,index){if(currentIndex.value===index){return node;}var result=null;if(node.a){currentIndex.value++;result=findBinaryTreeNodeByIndex(node.a,currentIndex,index);}if(node.b&&!result){currentIndex.value++;result=findBinaryTreeNodeByIndex(node.b,currentIndex,index);}return result;};var insertNodeIntoBinaryTreeAtIndex=function insertNodeIntoBinaryTreeAtIndex(parentNode,key,node,currentIndex,index,nodeToInsert){if(currentIndex.value===index){parentNode[key]=nodeToInsert;return true;}var result=null;if(node.a){currentIndex.value++;result=insertNodeIntoBinaryTreeAtIndex(node,'a',node.a,currentIndex,index,nodeToInsert);}if(node.b&&!result){currentIndex.value++;result=insertNodeIntoBinaryTreeAtIndex(node,'b',node.b,currentIndex,index,nodeToInsert);}return result;};var convertExpressionToWeightedArray=function convertExpressionToWeightedArray(tokenEvaluators,expression){var tree=expressionToTree(tokenEvaluators,expression);assignWeightToExpressionNode(tokenEvaluators,null,null,tree,0,expression.length);return treeToExpression(tree);};var assignWeightToExpressionNode=function assignWeightToExpressionNode(tokenEvaluators,parent,key,node,depth,expressionLength){if((typeof node==='undefined'?'undefined':_typeof(node))==='object'){if(node.a){assignWeightToExpressionNode(tokenEvaluators,node,'a',node.a,depth+1+depth*2,expressionLength);}if(node.b){assignWeightToExpressionNode(tokenEvaluators,node,'b',node.b,depth+1+depth*2,expressionLength);}//if(tokenEvaluators.singleOperators[node.value] || tokenEvaluators.doubleOperators[node.value]) {\nnode.value=depth;//} else {\nnode.value=depth;//}\n}else{parent[key]=depth;}};var crossOverExpressions=function crossOverExpressions(tokenEvaluators,getExpressionAIndex,getExpressionBIndex,expressionA,expressionB){var fromIndex=getExpressionAIndex(expressionA);var toIndex=getExpressionBIndex(expressionB);var parentFrom=expressionToTree(tokenEvaluators,expressionA.slice(0));var parentTo=expressionToTree(tokenEvaluators,expressionB.slice(0));var node=findBinaryTreeNodeByIndex(parentFrom,{value:0},fromIndex);var root={a:parentTo};if(node){if(insertNodeIntoBinaryTreeAtIndex(root,'a',parentTo,{value:0},toIndex,node)){return treeToExpression(root.a);}}throw new Error('Failed to cross over expressions');};var expressionToTree=function expressionToTree(tokenEvaluators,expression){var stack=[];var currentNode=null;var clonedExpression=expression.slice(0);while(clonedExpression.length){var currentToken=clonedExpression.shift();if(!tokenEvaluators.doubleOperators.hasOwnProperty(currentToken)&&!tokenEvaluators.singleOperators.hasOwnProperty(currentToken)){stack.push(currentToken);}else{if(stack.length>0){var b=stack.pop();if(tokenEvaluators.singleOperators.hasOwnProperty(currentToken)){currentNode={value:currentToken,a:b};stack.push(currentNode);}else{if(stack.length>0){var a=stack.pop();currentNode={value:currentToken,a:a,b:b};stack.push(currentNode);}}}}}if(stack.length===1&&!currentNode){currentNode={value:stack.pop()};}else if(stack.length>1){throw new Error('Stack not empty - unhandled condition: '+stack);}return currentNode;};var treeToString=function treeToString(node){var string='';if(node.a){string+='(';string+=treeToString(node.a);}if((typeof node==='undefined'?'undefined':_typeof(node))!=='object'){string+=node;}else{string+=node.value;}if(node.b){string+=treeToString(node.b);}if(node.a){string+=')';}return string;};var treeToExpression=function treeToExpression(node){var expression=[];if((typeof node==='undefined'?'undefined':_typeof(node))==='object'){if(node.hasOwnProperty('a')){expression=expression.concat(treeToExpression(node.a));}if(node.hasOwnProperty('b')){expression=expression.concat(treeToExpression(node.b));}if(node.hasOwnProperty('value')){expression.push(node.value);}}else{expression.push(node);}return expression;};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// e49daa7a80fbec29650a.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/imagene-web/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e49daa7a80fbec29650a","import {solveExpression, tokenEvaluators} from './expressions';\n\n//Small hack to support unit tests na dissues with mocking a web worker\nif(!global) {\n    globals = this;\n}\n\nglobal.onmessage = function(e) {\n    let dataArray = new Uint8ClampedArray(e.data.sample.width * e.data.sample.height * 4);\n    \n    let rgbRange = {\n        min: { r: false, g: false, b: false, all: false},\n        max: { r: false, g: false, b: false, all: false}\n    };\n    \n    let array = [];\n\n    for(let i = 0; i < dataArray.length; i += 4) {\n       \n        let x = i / 4 % e.data.sample.width;\n        let y = Math.floor(i / 4 / e.data.sample.height);\n        let evaluateX = x + 1;\n        let evaluateY = y + 1;\n\n        if(e.data.coordinateType === 'polar') { \n            let r, a;\n            evaluateX -= (e.data.sample.width / 2);\n            evaluateY -= (e.data.sample.height / 2);\n            \n            r = Math.sqrt(Math.pow(evaluateX, 2) + Math.pow(evaluateY, 2));\n\n            /* -90 to +270 */\n            // if (x == 0 && y == 0) {\n            //     a = 0;\n            // } else if (x >= 0) {\n            //     a = Math.asin(evaluateY / r);\n            // } else if (x < 0) {\n            //     a = 0 - Math.asin(evaluateY / r) + Math.PI;\n            // }\n\n            /* 0 to 360 */\n            // if (evaluateX > 0 && evaluateY >= 0){\n            //     a = Math.atan(evaluateY / evaluateX);\n            // }\n            // else if (evaluateX > 0 && evaluateY < 0) {\n            //     a = Math.atan(evaluateY / evaluateX) + Math.PI + Math.PI;\n            // }\n            // else if (evaluateX < 0) {\n            //     a = Math.atan(evaluateY / evaluateX) + Math.PI;\n            // }\n            // else if (evaluateX == 0 && evaluateY > 0) {\n            //     a = Math.PI / 2;\n            // }\n            // else if (evaluateX == 0 && evaluateY < 0) {\n            //     a = 3 / 2 * Math.PI;\n            // }\n            // else if (evaluateX == 0 && evaluateY == 0) {\n            //     a = 0;\n            // }\n\n            \n            /* -180 to +180 */\n            if (evaluateX > 0) { \n                a = Math.atan(evaluateY / evaluateX); \n            } else if (evaluateX < 0 && evaluateY >= 0) {\n                a = Math.atan(evaluateY / evaluateX) + Math.PI;\n            } else if (evaluateX < 0 && evaluateY < 0) {\n                a = Math.atan(evaluateY / evaluateX) - Math.PI;\n            } else if (evaluateX == 0 && evaluateY > 0) {\n                a = Math.PI / 2;\n            } else if (evaluateX == 0 && evaluateY < 0) {\n                a = 0 - Math.PI / 2;\n            } else if (evaluateX == 0 && evaluateY == 0) {\n                a = 0\n            }\n\n            evaluateX = r;\n            evaluateY = a;\n            \n        }   \n        \n\n        let r = solveExpression(tokenEvaluators, e.data.sample.redIndividual.expression.slice(0), evaluateX, evaluateY);\n        let g = solveExpression(tokenEvaluators, e.data.sample.greenIndividual.expression.slice(0), evaluateX, evaluateY);\n        let b = solveExpression(tokenEvaluators, e.data.sample.blueIndividual.expression.slice(0), evaluateX, evaluateY);\n\n        array[i] = r;\n        array[i + 1] = g;\n        array[i + 2] = b;\n        array[i + 3] = 255;\n       \n       \n        if(rgbRange.min.r === false || r < (rgbRange.min.r)) {\n            rgbRange.min.r = r;\n        }\n\n        if(rgbRange.min.g === false || g < (rgbRange.min.g)) {\n            rgbRange.min.g = g;\n        }\n\n        if(rgbRange.min.b === false || b < (rgbRange.min.b)) {\n            rgbRange.min.b = b;\n        }\n\n        if(rgbRange.max.r === false || r > (rgbRange.max.r)) {\n            rgbRange.max.r = r;\n        }\n\n        if(rgbRange.max.g === false || g > (rgbRange.max.g)) {\n            rgbRange.max.g = g;\n        }\n\n        if(rgbRange.max.b === false || b > (rgbRange.max.b)) {\n            rgbRange.max.b = b;\n        }\n    }\n    \n    \n    let diffs = {\n        r: rgbRange.max.r - rgbRange.min.r,\n        g: rgbRange.max.g - rgbRange.min.g,\n        b: rgbRange.max.b - rgbRange.min.b,\n    }\n    \n    let thresholdRanges = {\n        r: e.data.sample.redThreshold[1] - e.data.sample.redThreshold[0],\n        g: e.data.sample.greenThreshold[1] - e.data.sample.greenThreshold[0],\n        b: e.data.sample.blueThreshold[1] - e.data.sample.blueThreshold[0]\n    }\n    \n    for(let i = 0; i < dataArray.length; i+=4) {\n        \n        let r = array[i];\n        let g = array[i + 1];\n        let b = array[i + 2];\n        let a = array[i + 3];\n        \n        dataArray[i] = ((r - rgbRange.min.r) * thresholdRanges.r / diffs.r) + e.data.sample.redThreshold[0];\n        dataArray[i + 1] = ((g - rgbRange.min.g) * thresholdRanges.g / diffs.g) + e.data.sample.greenThreshold[0];\n        dataArray[i + 2] = ((b - rgbRange.min.b) * thresholdRanges.b / diffs.b) + e.data.sample.blueThreshold[0];\n        dataArray[i + 3] = a;\n    }\n\n    postMessage(dataArray);\n\n}.bind(this);\n\n\n// WEBPACK FOOTER //\n// ./src/lib/GenerationSampleWorker.worker.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0","\nexport const OPERATOR_DOUBLE = 'doubleOperators';\nexport const OPERATOR_SINGLE = 'singleOperators';\nexport const OPERAND = 'operands';\n\nexport const tokenEvaluators =  {\n        doubleOperators: {\n            '+': (a, b) => a + b,\n            '-': (a, b) => a - b,\n            '/': (a, b) => {\n                return a / (b === 0 ? 0.000000000000001 : b);\n            },\n            '*': (a, b) => a * b, \n            '^': (a, b) => {\n                if(a < 0 && (Math.abs(a) - parseInt(Math.abs(a), 10) >= 0)) {\n                    return Math.pow(Math.abs(a === 0 ? a + 0.000000000000001 : a), b);\n                } else {\n                    return Math.pow(a, b);\n                }\n            },\n            '%': (a, b) => {\n                return a % (b === 0 ? 0.000000000000001 : b);\n            },\n            'CIR': (a, b) => Math.sin(Math.sqrt(a * a + b * b) * Math.PI / 180.00)\n        },\n        singleOperators: {\n            'sqrt': (a) => Math.sqrt(Math.abs(a)),\n            'double': (a) => Math.pow(a, 2),\n            'triple': (a) => Math.pow(a, 3),\n            'sin': (a) => Math.sin(a % 3.16),\n            'cos': (a) => Math.cos(a % 3.16),\n            'tan': (a) => Math.tan(a),\n            'log': (a) => {\n                return Math.log(Math.abs(a) === 0 ? 0.000000000000001 : Math.abs(a));\n            }\n        },\n        operands: {\n            'pX': (x, y) => x,\n            'pY': (x, y) => y,\n            'PI': () => Math.PI\n        }\n};\n\nexport const tokenCreators = {\n    doubleOperators: {\n        '+': () => ['+'],\n        '-': () => ['-'],\n        '/': () => ['/'],\n        '*': () => ['*'], \n        '%': () => ['%'],\n        '^': () => ['^'],\n        'CIR': () => ['CIR']\n    },\n    singleOperators: {\n        'sqrt': () => ['sqrt'],\n        'sin': ()=> ['sin'],\n        'cos': ()=> ['cos'],\n        'tan': ()=> ['tan'],\n        'log': () => ['log'],\n        'double': () => ['double'],\n        'triple': () => ['triple']\n    },\n    operands: {\n        'pX': () => ['pX'],\n        'pY': () => ['pY'],\n        'PI': () => ['PI'],\n        'PIx': () => ['PI', 'pX', '*'],\n        'PIy': () => ['PI', 'pY', '*'],\n        'cosX': () => ['pX', 'cos'],\n        'cosY': () => ['pY', 'cos'],\n        'sinX': () => ['pX', 'sin'],\n        'sinY': () => ['pY', 'sin'],\n        'tanX': () => ['pX', 'tan'],\n        'tanY': () => ['pY', 'tan'],\n        'rand': (r) => [r(-10000, 10000)],\n        'randX': (r) => ['pX', r(-10000, 10000), '*'],\n        'randY': (r) => ['pY', r(-10000, 10000), '*'],\n        'CIR': () => ['pX', 'pY', 'CIR']\n    }\n};\n\n\nexport const getToken = (tokenCreators, getRandomReal, getRandomInteger, type) => {\n\n    let keys = Object.keys(tokenCreators[type]);\n    let item = keys[getRandomInteger(0, keys.length - 1)];\n    return tokenCreators[type][item](getRandomReal);\n    \n};\n\nexport const buildExpression = (tokenSelector, getRandomInteger, minSubexpressions, maxSubexpressions, currentDepth = 0) => {\n    let expression = [];\n    \n\n    let type = getRandomInteger(1, 2);\n    \n    //Build a double expression\n    if(type === 1) {\n        \n        //Build a nested double expression\n        if(currentDepth < maxSubexpressions) {\n            let currentMaxSubExpressions = getRandomInteger(minSubexpressions, maxSubexpressions);\n            expression = expression.concat(buildExpression(tokenSelector, getRandomInteger, minSubexpressions, currentMaxSubExpressions, currentDepth + 1));\n            expression = expression.concat(buildExpression(tokenSelector, getRandomInteger, minSubexpressions, currentMaxSubExpressions, currentDepth + 1));\n        } else {\n            //Build a flat double expression\n            expression = expression.concat(tokenSelector(OPERAND));\n            expression = expression.concat(tokenSelector(OPERAND));\n        }\n\n        expression = expression.concat(tokenSelector(OPERATOR_DOUBLE));\n\n    }//Build a single expression \n    else {\n        //Build a nested singular expression\n        if(currentDepth < maxSubexpressions) {\n            let currentMaxSubExpressions = getRandomInteger(minSubexpressions, maxSubexpressions);\n            expression = expression.concat(buildExpression(tokenSelector, getRandomInteger, minSubexpressions, currentMaxSubExpressions, currentDepth + 1));\n        } else {\n            //Build a flat singular expression\n            expression = expression.concat(tokenSelector(OPERAND));\n        }\n\n        expression = expression.concat(tokenSelector(OPERATOR_SINGLE));\n    }\n    \n    return expression;\n}\n\nexport const solveExpression = (tokenEvaluators, expression, x, y) => {\n    let operandStack = [];\n    let operatorStack = [];\n\n    while(expression.length) {\n        let n = expression.shift();\n       \n        if(!isNaN(parseFloat(n))) {\n            operandStack.push(parseFloat(n));\n        } else {\n            //If double operator\n            if(tokenEvaluators.doubleOperators.hasOwnProperty(n)) {\n                operatorStack.push(tokenEvaluators.doubleOperators[n]);\n\n            } //if single operator \n            else if(tokenEvaluators.singleOperators.hasOwnProperty(n)) {\n                operatorStack.push(tokenEvaluators.singleOperators[n]);\n\n            } //if operand \n            else if(tokenEvaluators.operands.hasOwnProperty(n)) {\n                let a = tokenEvaluators.operands[n](x, y);\n                if(isNaN(a)) {\n                    \n                } else if(!isFinite(a)) {\n                    \n                }\n\n                operandStack.push(a);\n            }\n        }\n        \n        //If we have enough operands and operators to attempt a solution\n        if(operandStack.length > 0 && operatorStack.length > 0) {\n            //Pop the function\n            let f = operatorStack.pop();\n            //initialise result and argument vars\n            let r, a, b;\n            //If function only expects a single argument\n            if(f.length === 1) {\n                //Pop the first operand\n                a = operandStack.pop();\n                //Evaluate the function\n                r = f(a);\n\n                if(isNaN(r)) {\n                    //console.log('Single Operator failure - NaN', f, a);\n                    r = a;\n                } else if(!isFinite(r)) {\n                    //console.log('Single Operator failure - infinite', f, a);\n                    //r = r === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : -Number.MAX_VALUE;\n                    r = a;\n                }\n\n                //Push the result back as an operand\n                operandStack.push(r);\n\n            } //Otherwise we are dealing with a double operator, so check if we have enough operands\n            else if(operandStack.length > 1) {\n\n                //Pop both arguments\n                b = operandStack.pop();\n                a = operandStack.pop();\n\n                //And evaluate the function\n                r = f(a, b);\n\n                if(isNaN(r)) {\n                    //console.log('Double Operator failure - NaN', f, a, b);\n                    r = Math.max(a, b);\n                } else if(!isFinite(r)) {\n                    //console.log('Double Operator failure - infinite', f, a, b);\n                    //r = r === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : -Number.MAX_VALUE;\n                    r = Math.max(a, b);\n                }\n\n                //Push the result back onto the operand stack\n                operandStack.push(r);\n\n            } else {\n                //No solution return operator\n                operatorStack.push(f);\n            }\n        }\n    }\n\n    //If we get to this point, and only a single operand exists, the solution has been found\n    if(operandStack.length === 1 && operatorStack.length === 0) {\n        //so return it\n        return operandStack.pop();\n    }\n    \n    //Otherwise we failed to solve\n    throw new Error('Unable to solve expression: operands: ' + operandStack + ' operators: ' + operatorStack);\n};\n\nexport const mutateExpression = (tokenEvaluators, getRandomInteger, getIndexToMutate, tokenSelector, expressionBuilder, expression) => {\n    let mutatedExpression = [...expression];\n    \n    let index = getIndexToMutate(expression);\n\n    let token = mutatedExpression[index];\n\n    if(tokenEvaluators.singleOperators.hasOwnProperty(token)) {\n\n        //Swap token for another operand\n        mutatedExpression.splice(index, 1, ...tokenSelector(OPERATOR_SINGLE));\n    }\n\n    if(tokenEvaluators.doubleOperators.hasOwnProperty(token)) {\n        //Swap token for another operand\n        mutatedExpression.splice(index, 1, ...tokenSelector(OPERATOR_DOUBLE));\n    }\n\n    if(tokenEvaluators.operands.hasOwnProperty(token)) {\n        let chance = getRandomInteger(0, 1);\n        switch(chance) {\n            case 0:\n                //Swap token for another operand\n                mutatedExpression.splice(index, 1, ...tokenSelector(OPERAND));\n                break;\n            case 1:\n            default:\n                //Swap token for a subexpression\n                mutatedExpression.splice(index, 1, ...expressionBuilder(0, 6, 0))\n                break;\n        }\n    }\n    return mutatedExpression;\n};\n\nexport const findBinaryTreeNodeByIndex = (node, currentIndex, index) => {\n    \n    if(currentIndex.value === index) {\n        return node;\n    }\n    \n    let result = null;\n    if(node.a) {\n        currentIndex.value++;\n        result = findBinaryTreeNodeByIndex(node.a, currentIndex, index);\n    }\n\n    if(node.b && !result) {\n        currentIndex.value++;\n        result = findBinaryTreeNodeByIndex(node.b, currentIndex, index);\n    }\n\n    return result;\n}\n \nexport const insertNodeIntoBinaryTreeAtIndex = (parentNode, key, node, currentIndex, index, nodeToInsert) => {\n   \n    if(currentIndex.value === index) {\n        parentNode[key] = nodeToInsert;\n        return true;\n    }\n\n    let result = null;\n    if(node.a) {\n        currentIndex.value++;\n        result = insertNodeIntoBinaryTreeAtIndex(node, 'a', node.a, currentIndex, index, nodeToInsert);\n    }\n\n    if(node.b && !result) {\n        currentIndex.value++;\n        result = insertNodeIntoBinaryTreeAtIndex(node, 'b', node.b, currentIndex, index, nodeToInsert);\n    }\n\n    \n    return result;\n}\n\n\n\nexport const convertExpressionToWeightedArray = (tokenEvaluators, expression) => {\n   let tree = expressionToTree(tokenEvaluators, expression);\n    assignWeightToExpressionNode(tokenEvaluators, null, null, tree, 0, expression.length);\n    return treeToExpression(tree);\n};\n\nexport const assignWeightToExpressionNode = (tokenEvaluators, parent, key, node, depth, expressionLength) => {\n    if(typeof node === 'object') {\n        if(node.a) {\n            assignWeightToExpressionNode(tokenEvaluators, node, 'a', node.a, depth + 1 + (depth * 2), expressionLength);\n        }\n        \n        if(node.b) {\n            assignWeightToExpressionNode(tokenEvaluators, node, 'b', node.b, depth + 1 + (depth * 2), expressionLength);\n        }\n\n        //if(tokenEvaluators.singleOperators[node.value] || tokenEvaluators.doubleOperators[node.value]) {\n            node.value = depth;\n        //} else {\n            node.value = depth;\n        //}\n    } else {\n        parent[key] = depth;\n    }\n}\n\n\nexport const crossOverExpressions = (tokenEvaluators, getExpressionAIndex, getExpressionBIndex, expressionA, expressionB)  => {\n\n    const fromIndex = getExpressionAIndex(expressionA);\n    const toIndex = getExpressionBIndex(expressionB);\n    \n    const parentFrom = expressionToTree(tokenEvaluators, expressionA.slice(0));\n    const parentTo = expressionToTree(tokenEvaluators, expressionB.slice(0));\n\n    const node = findBinaryTreeNodeByIndex(parentFrom, {value: 0}, fromIndex);\n\n    \n    let root = {\n        a: parentTo\n    }\n\n    \n    if(node) {\n        if(insertNodeIntoBinaryTreeAtIndex(root, 'a', parentTo, { value: 0 }, toIndex, node)) {\n            return treeToExpression(root.a);  \n        }\n    }\n\n    throw new Error('Failed to cross over expressions');\n}   \n\nexport const expressionToTree = (tokenEvaluators, expression) => {\n    \n    let stack = [];\n    let currentNode = null;\n    let clonedExpression = expression.slice(0);\n    while(clonedExpression.length) {\n\n        let currentToken = clonedExpression.shift();\n\n        if(!tokenEvaluators.doubleOperators.hasOwnProperty(currentToken) && !tokenEvaluators.singleOperators.hasOwnProperty(currentToken)) {\n            stack.push(currentToken);\n        } else {\n            \n            if(stack.length > 0) {\n                let b = stack.pop();\n                if(tokenEvaluators.singleOperators.hasOwnProperty(currentToken)) {\n                    currentNode = {\n                        value: currentToken, a: b\n                    }\n                    stack.push(currentNode);\n                } else {\n                    if(stack.length > 0) {\n                        let a = stack.pop();\n                        currentNode = { value: currentToken, a, b };\n                        stack.push(currentNode);\n                    }\n                }\n            }\n        }\n    }    \n\n    if(stack.length === 1 && !currentNode) {\n        currentNode = {\n            value: stack.pop()\n        }\n    } else if (stack.length > 1) {\n        throw new Error('Stack not empty - unhandled condition: ' + stack);\n    }\n\n    return currentNode;\n\n}\n\nexport const treeToString = function(node) {\n    \n    \n    var string = '';\n\n    if(node.a) {\n        string += '(';\n        string += treeToString(node.a)\n    }\n\n    if(typeof node !== 'object') {\n        string += node;\n    } else {\n        string += node.value;\n    }\n    \n    if(node.b) {\n        string += treeToString(node.b);\n        \n    }\n\n    if(node.a) {\n        string += ')';\n    }\n\n    return string;\n}\n\nexport const treeToExpression = function(node) {\n\n    let expression = [];\n    if(typeof node === 'object') {\n        \n        if(node.hasOwnProperty('a')) {\n            expression = expression.concat(treeToExpression(node.a));\n        }\n\n        if(node.hasOwnProperty('b')) {\n            expression = expression.concat(treeToExpression(node.b));\n        }   \n\n        if(node.hasOwnProperty('value')) {\n            expression.push(node.value);\n        }\n    } else {\n        expression.push(node);\n    }\n\n    return expression;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/expressions.js"],"sourceRoot":""}